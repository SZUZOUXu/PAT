//进制转换类
1010 Input:N1 N2 tag Radix
N1在Radix进制的条件下找到一个N2的进制使得N2 == N1
1.N1、N2在10进制的条件下进行比较
2.N2的Radix的范围:(最小的N2的位值+1,10进制的N1+1)
N1=10,N2=a;  使得N2==N1的Radix为10进制的N1+1=11
3.二分法

1015 Input:N D
N在D进制下是否是一个reversible prime
直接实现了10进制->radix进制，在radix进制下逆转，再->10进制
int reverse(int N, int radix) {
	int tmp = 0;
	while (N) {
		tmp = tmp * radix + N % radix;
		N = N / radix;
	}
	return tmp;
}

//排队问题
1014 Input:N M K Q N个窗户每个窗户M个人queue
1.最大容量为N*M;大于此数的统一等候
2.Window 包括队首完成的时间、队尾完成的时间、当前的队列
3.根据队首完成的时间入队，队尾完成的时间计算服务时间

1017 Input:N K N个人K个窗户priority_queue
与1014的区别在于没有限定每个窗户的人数 采用优先队列priority_queue，保证入队后也保持有序状态
1.P 包括来的时间、等待的时间
2.priority_queue<int, vector<int>, greater<int>>q;//按照到达银行的时间进行升序排序的优先队列
3.1014不能用优先队列是因为1014需要判断是入的哪一条队，用队尾完成的时间计算这个人服务完成的时间

1026 比较难的模拟排序
要有函数找下一个VIP在哪
1.当前的人是VIP的情况
有空闲的VIP桌子-分配VIP桌子
无空闲的VIP桌子-分配普通桌子
2.当前的人不是VIP的情况
要分配的桌子是VIP的情况-看看VIP能不能抢了
不是VIP-直接分配了

//找规律
1039
关键在于找到当前位出现1的次数
higher = N / (factor * 10);//当前位的高位
lower = N - (N / factor) * factor;//当前位的低位
cur = (N / factor) % 10;//当前位
1.当前位是0，由更高位决定
2.当前位是1，有高位和低位决定
3.当前位>1，由更高位决定
